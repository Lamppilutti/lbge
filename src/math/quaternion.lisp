(in-package :lbge.math)

(defclass quaternion ()
  ((x :accessor quaternion-x :initarg :x)
   (y :accessor quaternion-y :initarg :y)
   (z :accessor quaternion-z :initarg :z)
   (w :accessor quaternion-w :initarg :w)))

(defun make-quaternion (&key (x 0.0f0) (y 0.0f0) (z 0.0f0) (w 1.0f0))
  (make-instance 'quaternion :x x :y y :z z :w w))

(defmethod mul ((q1 quaternion) (q2 quaternion))
  (let ((a (* (+ (quaternion-w q1) (quaternion-x q1))
              (+ (quaternion-w q2) (quaternion-x q2))))
        (b (* (- (quaternion-z q1) (quaternion-y q1))
              (- (quaternion-y q2) (quaternion-z q2))))
        (c (* (- (quaternion-x q1) (quaternion-w q1))
              (+ (quaternion-y q2) (quaternion-z q2))))
        (d (* (+ (quaternion-y q1) (quaternion-z q1))
              (- (quaternion-x q2) (quaternion-w q2))))
        (e (* (+ (quaternion-x q1) (quaternion-z q1))
              (+ (quaternion-x q2) (quaternion-y q2))))
        (f (* (- (quaternion-x q1) (quaternion-z q1))
              (- (quaternion-x q2) (quaternion-y q2))))
        (g (* (+ (quaternion-w q1) (quaternion-y q1))
              (- (quaternion-w q2) (quaternion-z q2))))
        (h (* (- (quaternion-w q1) (quaternion-y q1))
              (+ (quaternion-w q2) (quaternion-z q2)))))
    (make-quaternion :x (- a (* 0.5f0 (+ e f g h)))
                     :y (+ (- c) (* 0.5f0 (+ e (- f) g (- h))))
                     :z (+ (- d) (* 0.5f0 (+ e (- f) (- g) h)))
                     :w (+ b (* 0.5f0 (+ (- e) (- f) g h))))))

(defmethod mul ((v float3) (q quaternion))
  (let* ((q-v (make-float3 (quaternion-x q) (quaternion-y q) (quaternion-z q)))
         (c (mul (cross q-v v) 2.0f0)))
    (add v (add (mul c (quaternion-w q)) (cross q-v c)))))

(defun from-euler (angle)
  (let* ((cz (round-to-eps (cos (* 0.5 (float3-z angle)))))
         (sz (round-to-eps (sin (* 0.5 (float3-z angle)))))
         (cx (round-to-eps (cos (* 0.5 (float3-x angle)))))
         (sx (round-to-eps (sin (* 0.5 (float3-x angle)))))
         (cy (round-to-eps (cos (* 0.5 (float3-y angle)))))
         (sy (round-to-eps (sin (* 0.5 (float3-y angle))))))
    (make-quaternion :x (- (* sx cy cz) (* cx sy sz))
                     :y (+ (* cx sy cz) (* sx cy sz))
                     :z (- (* cx cy sz) (* sx sy cz))
                     :w (+ (* cx cy cz) (* sx sy sz)))))

(defun to-euler (quat)
  (flet ((x (q) (quaternion-x q))
         (y (q) (quaternion-y q))
         (z (q) (quaternion-z q))
         (w (q) (quaternion-w q)))
    (let* ((y (* 2.0f0 (+ (* (y quat) (z quat))
                          (* (w quat) (x quat)))))
           (x (- (+ (* (w quat) (w quat))
                    (* (z quat) (z quat)))
                 (* (x quat) (x quat))
                 (* (y quat) (y quat))))
           (f.x (if (and (eqfp x 0.0f0) (eqfp y 0.0f0))
                  (* 2.0f0 (atan (x quat) (w quat)))
                  (atan y x)))
           (f.y (asin (clamp (* -2.0f0 (- (* (x quat) (z quat))
                                          (* (w quat) (y quat))))
                             -1.0f0 1.0f0)))
           (f.z (atan (* 2.0f0 (+ (* (x quat) (y quat))
                                  (* (w quat) (z quat))))
                      (- (+ (* (w quat) (w quat))
                            (* (x quat) (x quat)))
                         (* (z quat) (z quat))
                         (* (y quat) (y quat))))))
      (make-float3 f.x f.y f.z))))
